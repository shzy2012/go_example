package main

import (
	"fmt"
	"strings"
	"sync/atomic"
)

// ============================================
// 1. CAS 的伪代码逻辑
// ============================================

/*
CAS 的逻辑可以理解为以下伪代码（但实际是原子操作）：

func CompareAndSwapInt32(addr *int32, old, new int32) bool {
    // 注意：这些步骤在真实实现中是"原子的"，不可分割

    // 步骤1: 读取内存地址的当前值
    current := *addr

    // 步骤2: 比较当前值和期望的旧值
    if current == old {
        // 步骤3: 如果相等，写入新值
        *addr = new
        return true  // 交换成功
    }

    // 步骤4: 如果不相等，不做任何修改
    return false  // 交换失败
}

关键：上述所有步骤在硬件层面是一个"原子指令"，不会被其他CPU核心打断！
*/

// ============================================
// 2. 为什么需要 CAS？普通读写的问题
// ============================================

func demonstrateNormalOperationProblem() {
	fmt.Println("=== 普通操作的问题演示 ===\n")

	// 假设我们想实现一个简单的检查并设置
	// var value int32 = 0

	fmt.Println("❌ 错误的非原子实现：")
	fmt.Println(`
	// 这种写法在并发时是不安全的！
	if value == 0 {           // 步骤1: 读取
		                      // 【危险】可能在这里被其他goroutine打断
		value = 1             // 步骤2: 写入
	}
	
	问题：
	- Goroutine-A 读到 value=0
	- 【切换】Goroutine-B 读到 value=0  
	- Goroutine-A 设置 value=1
	- Goroutine-B 也设置 value=1
	- 结果：两个goroutine都认为自己成功了！（实际都执行了）
	`)

	fmt.Println("✅ 正确的原子实现：")
	fmt.Println(`
	// CAS 是原子的，不会被打断
	if atomic.CompareAndSwapInt32(&value, 0, 1) {
		// 只有一个goroutine能进入这里
	}
	`)
}

// ============================================
// 3. 底层汇编指令（不同架构）
// ============================================

func explainAssemblyInstructions() {
	fmt.Println("\n=== 不同CPU架构的底层指令 ===\n")

	fmt.Println("x86/x86-64 架构：")
	fmt.Println(`
	LOCK CMPXCHG 指令
	
	汇编示例：
	    LOCK CMPXCHG [addr], new_value
	    
	执行过程：
	    1. LOCK 前缀锁定内存总线（确保原子性）
	    2. CMPXCHG 比较 EAX 寄存器与 [addr] 的值
	    3. 如果相等：将 new_value 写入 [addr]，设置 ZF=1
	    4. 如果不等：将 [addr] 的值加载到 EAX，设置 ZF=0
	    5. 根据 ZF 标志位返回结果
	`)

	fmt.Println("ARM 架构（ARMv8）：")
	fmt.Println(`
	LDAXR/STLXR 指令对（Load-Link/Store-Conditional）
	
	汇编示例：
	retry:
	    LDAXR  W1, [X0]        // 独占加载
	    CMP    W1, W2          // 比较
	    B.NE   fail            // 不相等则失败
	    STLXR  W4, W3, [X0]    // 独占存储
	    CBNZ   W4, retry       // 如果失败则重试
	    
	特点：使用"独占监视器"机制
	`)

	fmt.Println("RISC-V 架构：")
	fmt.Println(`
	LR/SC 指令对（Load-Reserved/Store-Conditional）
	
	类似 ARM 的机制
	`)
}

// ============================================
// 4. Go 语言的实现路径
// ============================================

func explainGoImplementation() {
	fmt.Println("\n=== Go 语言实现路径 ===\n")

	fmt.Println("调用链：")
	fmt.Println(`
	1. 应用代码：
	   atomic.CompareAndSwapInt32(&value, 0, 1)
	   
	2. Go 标准库 (sync/atomic/doc.go)：
	   func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
	   
	3. 编译器内置函数（compiler intrinsic）：
	   - 编译器识别这是原子操作
	   - 直接生成对应的汇编指令
	   - 不走普通函数调用流程
	   
	4. 汇编实现 (runtime/internal/atomic/atomic_xxx.s)：
	   - x86: src/runtime/internal/atomic/atomic_amd64.s
	   - ARM: src/runtime/internal/atomic/atomic_arm64.s
	   - 直接调用 CPU 的原子指令
	`)

	fmt.Println("\n实际汇编代码片段（x86-64）：")
	fmt.Println(`
	TEXT ·Cas(SB),NOSPLIT,$0
	    MOVQ    ptr+0(FP), BX      // 加载地址到 BX
	    MOVL    old+8(FP), AX      // 加载旧值到 AX
	    MOVL    new+12(FP), CX     // 加载新值到 CX
	    LOCK                       // 锁定总线
	    CMPXCHGL CX, 0(BX)         // 原子比较并交换
	    SETEQ   ret+16(FP)         // 设置返回值
	    RET
	`)
}

// ============================================
// 5. 硬件层面的原子性保证
// ============================================

func explainHardwareAtomicity() {
	fmt.Println("\n=== 硬件层面如何保证原子性 ===\n")

	fmt.Println("方法1：总线锁（Bus Lock）- x86 LOCK 前缀")
	fmt.Println(`
	- 执行 CAS 指令时锁定内存总线
	- 其他 CPU 核心无法访问该内存地址
	- 性能开销较大（阻塞其他核心）
	- 适用于旧架构或跨缓存行操作
	`)

	fmt.Println("\n方法2：缓存锁（Cache Lock）- 现代 CPU")
	fmt.Println(`
	- 如果数据在 CPU 缓存中且独占
	- 只锁定缓存行（Cache Line），不锁总线
	- 通过 MESI 协议保证缓存一致性
	- 性能远优于总线锁
	
	MESI 协议：
	  M (Modified)   - 已修改，独占
	  E (Exclusive)  - 独占，未修改
	  S (Shared)     - 共享，只读
	  I (Invalid)    - 无效
	`)

	fmt.Println("\n方法3：独占监视器（ARM/RISC-V）")
	fmt.Println(`
	- LDAXR 设置"独占监视器"标记该地址
	- 如果其他核心写入该地址，监视器失效
	- STLXR 检查监视器，失效则写入失败
	- 需要软件层面重试
	`)
}

// ============================================
// 6. 实际性能演示
// ============================================

func demonstratePerformance() {
	fmt.Println("\n=== CAS 操作性能特征 ===\n")

	var value int32 = 0

	// 无竞争场景：非常快
	fmt.Println("场景1：无竞争（成功率 100%）")
	success := atomic.CompareAndSwapInt32(&value, 0, 1)
	fmt.Printf("  结果: %v (延迟: ~几纳秒)\n", success)

	// 有竞争场景：会失败
	fmt.Println("\n场景2：有竞争（失败会立即返回）")
	atomic.StoreInt32(&value, 5)
	success = atomic.CompareAndSwapInt32(&value, 0, 1)
	fmt.Printf("  结果: %v (失败但不阻塞，延迟: ~几纳秒)\n", success)

	fmt.Println("\n性能对比：")
	fmt.Println(`
	操作类型              延迟（近似）
	----------------------------------------
	CAS (成功)           1-5 ns
	CAS (失败)           1-5 ns
	mutex.Lock()         20-50 ns (无竞争)
	channel send/recv    50-100 ns
	Context 切换         1-2 μs (微秒)
	
	注意：CAS 在高竞争下会导致大量重试，反而不如 mutex
	`)
}

// ============================================
// 7. 内存顺序保证（Memory Ordering）
// ============================================

func explainMemoryOrdering() {
	fmt.Println("\n=== 内存顺序保证 ===\n")

	fmt.Println("CAS 提供的内存屏障（Memory Barrier）：")
	fmt.Println(`
	在 Go 中，atomic 操作提供 Sequential Consistency：
	
	Before CAS:        CAS Operation:       After CAS:
	┌─────────┐       ┌────────────┐       ┌─────────┐
	│ Write A │ ───→  │  CAS on X  │ ───→  │ Read B  │
	└─────────┘       └────────────┘       └─────────┘
	     ↓                   ↓                    ↑
	  不会被重排序        原子操作            不会被重排序
	
	保证：
	1. CAS 之前的写操作，对所有 CPU 可见后才执行 CAS
	2. CAS 之后的读操作，一定看到 CAS 的结果
	3. 其他 CPU 看到的操作顺序一致
	`)

	// 实际示例
	var flag int32 = 0
	var data int32 = 0

	// Goroutine 1 (Writer)
	go func() {
		atomic.StoreInt32(&data, 100) // 写入数据
		atomic.StoreInt32(&flag, 1)   // 设置标志
		// 保证：data 的写入对其他 goroutine 可见后，才会设置 flag
	}()

	// Goroutine 2 (Reader)
	go func() {
		if atomic.LoadInt32(&flag) == 1 { // 读取标志
			value := atomic.LoadInt32(&data) // 读取数据
			fmt.Printf("读到 data = %d (一定是100，不会是旧值0)\n", value)
			// 保证：能看到 flag=1，就一定能看到 data=100
		}
	}()
}

// ============================================
// 8. CAS 的 ABA 问题
// ============================================

func demonstrateABAProblem() {
	fmt.Println("\n=== ABA 问题演示 ===\n")

	fmt.Println("问题场景：")
	fmt.Println(`
	时间线：
	t0: value = A (比如指针指向节点A)
	t1: Goroutine-1 读取 value (看到 A)
	t2: Goroutine-2 将 value 改为 B
	t3: Goroutine-2 将 value 改回 A  ← 问题！
	t4: Goroutine-1 执行 CAS(A→C) ✅ 成功！
	
	问题：Goroutine-1 认为值没变，但实际发生了 A→B→A 的变化
	
	解决方案：
	1. 使用版本号：CAS(value+version)
	2. 使用指针标记位
	3. 在 Go 中可以用结构体包装：
	   type Versioned struct {
	       Value   int32
	       Version int32
	   }
	`)
}

// ============================================
// Main 函数
// ============================================

func main() {
	demonstrateNormalOperationProblem()
	explainAssemblyInstructions()
	explainGoImplementation()
	explainHardwareAtomicity()
	demonstratePerformance()
	explainMemoryOrdering()
	demonstrateABAProblem()

	fmt.Println("\n" + strings.Repeat("=", 60))
	fmt.Println("总结：")
	fmt.Println(strings.Repeat("=", 60))
	fmt.Println(`
	1. CAS 是一个硬件级别的原子操作
	2. 通过 CPU 的专用指令实现（LOCK CMPXCHG、LDAXR/STLXR等）
	3. 硬件通过总线锁或缓存锁保证原子性
	4. Go 编译器直接生成对应的汇编指令
	5. 提供内存顺序保证，防止指令重排序
	6. 性能高但在高竞争场景下可能不如互斥锁
	`)
}

// ============================================
// 补充：查看实际汇编代码
// ============================================

/*
如何查看 Go 生成的汇编代码：

1. 编译时生成汇编：
   go build -gcflags="-S" main.go 2>&1 | grep -A 10 "CompareAndSwap"

2. 使用 go tool compile：
   go tool compile -S main.go | grep -A 10 "CompareAndSwap"

3. 查看运行时代码：
   cat $GOROOT/src/runtime/internal/atomic/atomic_amd64.s

示例输出（x86-64）：
   0x001d MOVQ    "".&value+8(SP), AX
   0x0022 MOVL    $0, CX
   0x0027 MOVL    $1, DX
   0x002c LOCK
   0x002d CMPXCHGL    DX, (AX)
   0x0030 SETE    AL
*/
