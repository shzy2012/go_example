package main

import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

// ============================================
// 你的原始实现逻辑演示
// ============================================

var _isRuning int32

func SlotCount(id int) {
	// CAS 操作：只有当 _isRuning 为 0 时，才能设置为 1
	// 返回 true 表示成功获取执行权限
	// 返回 false 表示已有其他 goroutine 在执行
	if !atomic.CompareAndSwapInt32(&_isRuning, 0, 1) {
		fmt.Printf("❌ Goroutine-%d: 任务正在执行中，跳过本次调用\n", id)
		return
	}

	// 确保函数退出时重置标志位
	defer atomic.StoreInt32(&_isRuning, 0)

	// 模拟实际的业务逻辑（耗时操作）
	fmt.Printf("✅ Goroutine-%d: 开始执行任务...\n", id)
	time.Sleep(2 * time.Second) // 模拟耗时操作
	fmt.Printf("✅ Goroutine-%d: 任务执行完成\n", id)
}

// ============================================
// 并发执行演示
// ============================================

func main() {
	fmt.Println("=== 场景1: 5个 goroutine 并发调用 ===")

	var wg sync.WaitGroup

	// 启动 5 个 goroutine 同时调用
	for i := 1; i <= 5; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			SlotCount(id)
		}(i)
	}

	wg.Wait()

	// ============================================
	// 场景2: 连续调用演示
	// ============================================

	fmt.Println("=== 场景2: 等待任务完成后再次调用 ===")
	time.Sleep(100 * time.Millisecond) // 确保上一个任务已完成

	wg.Add(1)
	go func() {
		defer wg.Done()
		SlotCount(6)
	}()

	wg.Wait()

	// ============================================
	// 场景3: 详细的执行时序演示
	// ============================================

	fmt.Println("=== 场景3: 详细执行时序 ===")
	demonstrateDetailedTiming()

	// ============================================
	// 场景4: 高并发压测
	// ============================================

	fmt.Println("=== 场景4: 100个并发调用 ===")
	demonstrateHighConcurrency()
}

// 详细的时序演示
func demonstrateDetailedTiming() {
	_isRuning = 0 // 重置状态

	startTime := time.Now()
	var wg sync.WaitGroup

	for i := 1; i <= 10; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			elapsed := time.Since(startTime).Milliseconds()
			fmt.Printf("[%04dms] Goroutine-%d 尝试获取执行权限\n", elapsed, id)

			if !atomic.CompareAndSwapInt32(&_isRuning, 0, 1) {
				elapsed := time.Since(startTime).Milliseconds()
				fmt.Printf("[%04dms] ❌ Goroutine-%d 被拒绝（任务正在执行）\n", elapsed, id)
				return
			}

			elapsed = time.Since(startTime).Milliseconds()
			fmt.Printf("[%04dms] ✅ Goroutine-%d 获取执行权限成功！\n", elapsed, id)
			defer atomic.StoreInt32(&_isRuning, 0)

			time.Sleep(500 * time.Millisecond)

			elapsed = time.Since(startTime).Milliseconds()
			fmt.Printf("[%04dms] ✅ Goroutine-%d 执行完成\n", elapsed, id)
		}(i)

		// 稍微错开启动时间
		time.Sleep(10 * time.Millisecond)
	}

	wg.Wait()
}

// 高并发压测
func demonstrateHighConcurrency() {
	_isRuning = 0 // 重置状态

	var successCount int32
	var rejectedCount int32
	var wg sync.WaitGroup

	// 100个 goroutine 并发调用
	for i := 1; i <= 100; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()

			if !atomic.CompareAndSwapInt32(&_isRuning, 0, 1) {
				atomic.AddInt32(&rejectedCount, 1)
				return
			}

			atomic.AddInt32(&successCount, 1)
			defer atomic.StoreInt32(&_isRuning, 0)

			// 模拟短时间任务
			time.Sleep(100 * time.Millisecond)
		}(i)
	}

	wg.Wait()

	fmt.Printf("执行成功: %d 次\n", successCount)
	fmt.Printf("被拒绝: %d 次\n", rejectedCount)
	fmt.Printf("总调用: %d 次\n", successCount+rejectedCount)
}

// ============================================
// 执行流程图解
// ============================================

/*
执行时序图：

时间轴    Goroutine-1          Goroutine-2          Goroutine-3
------    -----------          -----------          -----------
t0        尝试 CAS
t1        ✅ 成功 (0→1)
t2        执行业务逻辑          尝试 CAS
t3        ...                 ❌ 失败 (_isRuning=1)
t4        ...                 返回(跳过)           尝试 CAS
t5        ...                                      ❌ 失败
t6        ...                                      返回(跳过)
t7        执行完成
t8        defer: 1→0
t9        (标志位已重置为0，可以接受新的调用)


关键点说明：

1. atomic.CompareAndSwapInt32(&_isRuning, 0, 1)
   - 原子操作，不会被打断
   - 只有第一个到达的 goroutine 能成功
   - 其他 goroutine 立即返回 false

2. defer atomic.StoreInt32(&_isRuning, 0)
   - 确保即使 panic 也能释放锁
   - 函数正常或异常退出都会执行

3. 被拒绝的 goroutine
   - 直接返回，不会等待
   - 不会阻塞或重试
   - 适合"宁可丢失也不重复执行"的场景
*/
